# -*- generated by 1.0.12 -*-
import da
PatternExpr_462 = da.pat.TuplePattern([da.pat.ConstantPattern('perf_time_start'), da.pat.FreePattern('run_num'), da.pat.FreePattern('elapsed_time_start'), da.pat.FreePattern('process_time_start'), da.pat.FreePattern('implementation')])
PatternExpr_475 = da.pat.FreePattern('parent')
PatternExpr_494 = da.pat.TuplePattern([da.pat.ConstantPattern('perf_time_end'), da.pat.FreePattern('run_num'), da.pat.FreePattern('elapsed_time_end'), da.pat.FreePattern('process_time_end'), da.pat.FreePattern('implementation')])
PatternExpr_507 = da.pat.FreePattern('parent')
PatternExpr_640 = da.pat.TuplePattern([da.pat.ConstantPattern('perf_print_times'), da.pat.FreePattern('implementation')])
PatternExpr_647 = da.pat.FreePattern('parent')
PatternExpr_964 = da.pat.TuplePattern([da.pat.ConstantPattern('perf_value_not_learned_dur_perf'), da.pat.FreePattern('run_num'), da.pat.FreePattern('implementation')])
PatternExpr_973 = da.pat.FreePattern('learner')
PatternExpr_1026 = da.pat.TuplePattern([da.pat.ConstantPattern('perf_refresh_perf'), da.pat.FreePattern('implementation')])
PatternExpr_1081 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_1086 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_1262 = da.pat.TuplePattern([da.pat.ConstantPattern('perf_refresh'), da.pat.FreePattern('implementation')])
PatternExpr_1300 = da.pat.TuplePattern([da.pat.ConstantPattern('perf_val_proposed'), da.pat.FreePattern('v'), da.pat.FreePattern('implementation')])
PatternExpr_1320 = da.pat.TuplePattern([da.pat.ConstantPattern('perf_value_learned'), da.pat.FreePattern('v'), da.pat.FreePattern('run_num'), da.pat.FreePattern('implementation')])
PatternExpr_1331 = da.pat.FreePattern('learner')
PatternExpr_1366 = da.pat.TuplePattern([da.pat.ConstantPattern('perf_value_not_learned'), da.pat.FreePattern('run_num'), da.pat.FreePattern('implementation')])
PatternExpr_1375 = da.pat.FreePattern('learner')
PatternExpr_1545 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_1550 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_1663 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern1666_'), da.pat.FreePattern(None)])
PatternExpr_1670 = da.pat.FreePattern('a')
PatternExpr_1698 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern1701_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern('v')])])
PatternExpr_1729 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern1732_'), da.pat.TuplePattern([da.pat.FreePattern('n2'), da.pat.FreePattern(None)])])
PatternExpr_1765 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.BoundPattern('_BoundPattern1768_'), da.pat.FreePattern(None)])
PatternExpr_1772 = da.pat.FreePattern('a')
PatternExpr_1813 = da.pat.TuplePattern([da.pat.ConstantPattern('preempted'), da.pat.FreePattern('n2')])
PatternExpr_1859 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_1864 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_1996 = da.pat.TuplePattern([da.pat.ConstantPattern('prepare'), da.pat.FreePattern('n')])
PatternExpr_2003 = da.pat.FreePattern('p')
PatternExpr_2009 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_2038 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_2064 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern(None)])
PatternExpr_2099 = da.pat.TuplePattern([da.pat.ConstantPattern('accept'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_2112 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('n2'), da.pat.FreePattern(None)])
PatternExpr_2145 = da.pat.FreePattern('m')
PatternExpr_2149 = da.pat.FreePattern('p')
PatternExpr_2162 = da.pat.TuplePattern([da.pat.ConstantPattern('respond'), da.pat.FreePattern('b'), da.pat.FreePattern(None)])
PatternExpr_2208 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_2213 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_2353 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_2379 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern2382_'), da.pat.BoundPattern('_BoundPattern2383_')])
PatternExpr_2386 = da.pat.FreePattern('a')
PatternExpr_2853 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_2858 = da.pat.BoundPattern('_BoundPattern2859_')
PatternExpr_2937 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_2942 = da.pat.BoundPattern('_BoundPattern2943_')
PatternExpr_2860 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2866_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_2944 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2950_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
_config_object = {}
import sys
from random import randint
import random
import time
import statistics
orig = da.import_da('orig')
TIMEOUT = 1

class Performance(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._PerformanceReceivedEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_PerformanceReceivedEvent_0', PatternExpr_462, sources=[PatternExpr_475], destinations=None, timestamps=None, record_history=None, handlers=[self._Performance_handler_461]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PerformanceReceivedEvent_1', PatternExpr_494, sources=[PatternExpr_507], destinations=None, timestamps=None, record_history=None, handlers=[self._Performance_handler_493]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PerformanceReceivedEvent_2', PatternExpr_640, sources=[PatternExpr_647], destinations=None, timestamps=None, record_history=None, handlers=[self._Performance_handler_639]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PerformanceReceivedEvent_3', PatternExpr_964, sources=[PatternExpr_973], destinations=None, timestamps=None, record_history=None, handlers=[self._Performance_handler_963]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PerformanceReceivedEvent_4', PatternExpr_1026, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Performance_handler_1025]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PerformanceReceivedEvent_5', PatternExpr_1081, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, parent, nlearners, runs, loss_rate, message_delay, round_time, tout_prop, tout_learn, implementations, **rest_2960):
        super().setup(parent=parent, nlearners=nlearners, runs=runs, loss_rate=loss_rate, message_delay=message_delay, round_time=round_time, tout_prop=tout_prop, tout_learn=tout_learn, implementations=implementations, **rest_2960)
        self._state.parent = parent
        self._state.nlearners = nlearners
        self._state.runs = runs
        self._state.loss_rate = loss_rate
        self._state.message_delay = message_delay
        self._state.round_time = round_time
        self._state.tout_prop = tout_prop
        self._state.tout_learn = tout_learn
        self._state.implementations = implementations
        self._state.times_file = dict()
        self._state.elapsed_time = dict()
        self._state.elapsed_times = dict()
        self._state.process_time = dict()
        self._state.process_times = dict()
        self._state.values_proposed = dict()
        self._state.proposals_learned = dict()
        self._state.correctness_file = dict()
        self._state.learners_num = dict()
        self._state.learning_failed = dict()
        for implementation in self._state.implementations:
            self._state.times_file[implementation] = open((('times_' + implementation) + '.txt'), 'a')
            self._state.elapsed_time[implementation] = 0.0
            self._state.elapsed_times[implementation] = []
            self._state.process_time[implementation] = 0.0
            self._state.process_times[implementation] = []
            self._state.times_file[implementation].write((((((((((((((implementation.upper() + ' Run for: ') + str(self._state.runs)) + ' runs, loss rate:') + str(self._state.loss_rate)) + ', message delay:') + str(self._state.message_delay)) + ', round time:') + str(self._state.round_time)) + ', timeout for proposers:') + str(self._state.tout_prop)) + ', timeout for learners:') + str(self._state.tout_learn)) + '\n'))
            self._state.values_proposed[implementation] = set()
            self._state.proposals_learned[implementation] = []
            self._state.correctness_file[implementation] = open((('correctness_' + implementation) + '.txt'), 'a')
            self._state.learners_num[implementation] = 0.0
            self._state.learning_failed[implementation] = False
            self._state.correctness_file[implementation].write((((((((((((((implementation.upper() + ' Run for: ') + str(self._state.runs)) + ' runs, loss rate:') + str(self._state.loss_rate)) + ', message delay:') + str(self._state.message_delay)) + ', round time:') + str(self._state.round_time)) + ', timeout for proposers:') + str(self._state.tout_prop)) + ', timeout for learners:') + str(self._state.tout_learn)) + '\n'))

    def run(self):
        super()._label('_st_label_1078', block=False)
        _st_label_1078 = 0
        while (_st_label_1078 == 0):
            _st_label_1078 += 1
            if PatternExpr_1086.match_iter(self._PerformanceReceivedEvent_5, SELF_ID=self._id):
                _st_label_1078 += 1
            else:
                super()._label('_st_label_1078', block=True)
                _st_label_1078 -= 1
        self.send(('done',), to=self.parent())
        self.output('Performance Terminating. Goodbye.')

    def _Performance_handler_461(self, run_num, elapsed_time_start, process_time_start, implementation, parent):
        self._state.elapsed_time[implementation] = elapsed_time_start
        self._state.process_time[implementation] = process_time_start
    _Performance_handler_461._labels = None
    _Performance_handler_461._notlabels = None

    def _Performance_handler_493(self, run_num, elapsed_time_end, process_time_end, implementation, parent):
        self._state.times_file[implementation].write(((((('-' * 40) + 'Run number') + str((run_num + 1))) + ('-' * 40)) + '\n'))
        if (not self._state.learning_failed[implementation]):
            self._state.elapsed_time[implementation] = (elapsed_time_end - self._state.elapsed_time[implementation])
            self._state.elapsed_times[implementation].append(self._state.elapsed_time[implementation])
            self._state.times_file[implementation].write((('Elapsed time is: ' + str(round(self._state.elapsed_time[implementation], 5))) + ' seconds.\n'))
            self._state.process_time[implementation] = (process_time_end - self._state.process_time[implementation])
            self._state.process_times[implementation].append(self._state.process_time[implementation])
            self._state.times_file[implementation].write((('Process time is: ' + str(round(self._state.process_time[implementation], 5))) + ' seconds.\n'))
    _Performance_handler_493._labels = None
    _Performance_handler_493._notlabels = None

    def _Performance_handler_639(self, implementation, parent):
        if (len(self._state.elapsed_times[implementation]) > 1):
            self._state.times_file[implementation].write(((((' ' * 40) + 'Averages and Ranges') + (' ' * 40)) + '\n'))
            self._state.times_file[implementation].write((((('Average elapsed time for the ' + str(len(self._state.elapsed_times[implementation]))) + ' runs is: ') + str(round(statistics.mean(self._state.elapsed_times[implementation]), 5))) + ' seconds.\n'))
            self._state.times_file[implementation].write((((('Standard deviation for elapsed time for the ' + str(len(self._state.elapsed_times[implementation]))) + ' runs is: ') + str(round(statistics.stdev(self._state.elapsed_times[implementation]), 5))) + ' seconds.\n'))
            self._state.times_file[implementation].write((((('Range for elapsed time for the ' + str(len(self._state.elapsed_times[implementation]))) + ' runs is: ') + str(round((max(self._state.elapsed_times[implementation]) - min(self._state.elapsed_times[implementation])), 5))) + ' seconds.\n'))
            self._state.times_file[implementation].write((('\n' + (' ' * 100)) + '\n'))
        if (len(self._state.process_times[implementation]) > 1):
            self._state.times_file[implementation].write(((((' ' * 40) + 'Averages and Ranges') + (' ' * 40)) + '\n'))
            self._state.times_file[implementation].write((((('Average process time for the ' + str(len(self._state.process_times[implementation]))) + ' runs is: ') + str(round(statistics.mean(self._state.process_times[implementation]), 5))) + ' seconds.\n'))
            self._state.times_file[implementation].write((((('Standard deviation for process time for the ' + str(len(self._state.process_times[implementation]))) + ' runs is: ') + str(round(statistics.stdev(self._state.process_times[implementation]), 5))) + ' seconds.\n\n'))
            self._state.times_file[implementation].write((((('Range for process time for the ' + str(len(self._state.process_times[implementation]))) + ' runs is: ') + str(round((max(self._state.process_times[implementation]) - min(self._state.process_times[implementation])), 5))) + ' seconds.\n'))
            self._state.times_file[implementation].write((('\n' + ('%' * 80)) + '\n'))
    _Performance_handler_639._labels = None
    _Performance_handler_639._notlabels = None

    def _Performance_handler_963(self, run_num, implementation, learner):
        if (not self._state.learning_failed[implementation]):
            self._state.correctness_file[implementation].write(((((('-' * 40) + 'Run number') + str((run_num + 1))) + ('-' * 40)) + '\n'))
            self._state.correctness_file[implementation].write('\nTermination condition was violated. \n')
            self._state.learning_failed[implementation] = True
    _Performance_handler_963._labels = None
    _Performance_handler_963._notlabels = None

    def _Performance_handler_1025(self, implementation):
        self._state.values_proposed[implementation] = set()
        self._state.proposals_learned[implementation] = []
        self._state.learners_num[implementation] = 0
        self._state.learning_failed[implementation] = False
        self._state.process_time[implementation] = 0
        self._state.elapsed_time[implementation] = 0
    _Performance_handler_1025._labels = None
    _Performance_handler_1025._notlabels = None

class Correctness(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._CorrectnessReceivedEvent_4 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessReceivedEvent_0', PatternExpr_1262, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Correctness_handler_1261]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessReceivedEvent_1', PatternExpr_1300, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Correctness_handler_1299]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessReceivedEvent_2', PatternExpr_1320, sources=[PatternExpr_1331], destinations=None, timestamps=None, record_history=None, handlers=[self._Correctness_handler_1319]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessReceivedEvent_3', PatternExpr_1366, sources=[PatternExpr_1375], destinations=None, timestamps=None, record_history=None, handlers=[self._Correctness_handler_1365]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessReceivedEvent_4', PatternExpr_1545, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, parent, nlearners, runs, loss_rate, message_delay, round_time, tout_prop, tout_learn, implementations, **rest_2960):
        super().setup(parent=parent, nlearners=nlearners, runs=runs, loss_rate=loss_rate, message_delay=message_delay, round_time=round_time, tout_prop=tout_prop, tout_learn=tout_learn, implementations=implementations, **rest_2960)
        self._state.parent = parent
        self._state.nlearners = nlearners
        self._state.runs = runs
        self._state.loss_rate = loss_rate
        self._state.message_delay = message_delay
        self._state.round_time = round_time
        self._state.tout_prop = tout_prop
        self._state.tout_learn = tout_learn
        self._state.implementations = implementations
        self._state.values_proposed = dict()
        self._state.proposals_learned = dict()
        self._state.correctness_file = dict()
        self._state.learners_num = dict()
        self._state.learning_failed = dict()
        for implementation in self._state.implementations:
            self._state.values_proposed[implementation] = set()
            self._state.proposals_learned[implementation] = []
            self._state.correctness_file[implementation] = open((('correctness_' + implementation) + '.txt'), 'a')
            self._state.learners_num[implementation] = 0.0
            self._state.learning_failed[implementation] = False
            self._state.correctness_file[implementation].write((((((((((((((implementation.upper() + 'Run for: ') + str(self._state.runs)) + ' runs, loss rate:') + str(self._state.loss_rate)) + ', message delay:') + str(self._state.message_delay)) + ', round time:') + str(self._state.round_time)) + ', timeout for proposers:') + str(self._state.tout_prop)) + ', timeout for learners:') + str(self._state.tout_learn)) + '\n'))

    def run(self):
        super()._label('_st_label_1542', block=False)
        _st_label_1542 = 0
        while (_st_label_1542 == 0):
            _st_label_1542 += 1
            if PatternExpr_1550.match_iter(self._CorrectnessReceivedEvent_4, SELF_ID=self._id):
                _st_label_1542 += 1
            else:
                super()._label('_st_label_1542', block=True)
                _st_label_1542 -= 1
        self.send(('done',), to=self.parent())
        self.output('Correctness Terminating. Goodbye.')

    def print_correctness(self, run_num, implementation):
        super()._label('_st_label_1430', block=False)
        _st_label_1430 = 0
        while (_st_label_1430 == 0):
            _st_label_1430 += 1
            if (len(self._state.proposals_learned[implementation]) == self._state.learners_num[implementation]):
                self._state.correctness_file[implementation].write(((((('-' * 40) + 'Run number') + str((run_num + 1))) + ('-' * 40)) + '\n'))
                self._state.correctness_file[implementation].write('Termination condition is satisfied, all the learners have learned a value. \n')
                self._state.correctness_file[implementation].write('Values that were proposed are: \n')
                for value in self._state.values_proposed[implementation]:
                    self._state.correctness_file[implementation].write((str(value) + ' '))
                self._state.correctness_file[implementation].write('\nThe value that was chosen by the learners is: ')
                for val in self._state.proposals_learned[implementation]:
                    self._state.correctness_file[implementation].write((str(val) + '\n\n'))
                _st_label_1430 += 1
            else:
                super()._label('_st_label_1430', block=True)
                _st_label_1430 -= 1

    def _Correctness_handler_1261(self, implementation):
        self._state.values_proposed[implementation] = set()
        self._state.proposals_learned[implementation] = []
        self._state.learners_num[implementation] = 0
        self._state.learning_failed[implementation] = False
    _Correctness_handler_1261._labels = None
    _Correctness_handler_1261._notlabels = None

    def _Correctness_handler_1299(self, v, implementation):
        self._state.values_proposed[implementation].add(v)
    _Correctness_handler_1299._labels = None
    _Correctness_handler_1299._notlabels = None

    def _Correctness_handler_1319(self, v, run_num, implementation, learner):
        if (not (v in self._state.proposals_learned[implementation])):
            self._state.proposals_learned[implementation].append(v)
            self._state.learners_num[implementation] += 1
            self.print_correctness(run_num, implementation)
    _Correctness_handler_1319._labels = None
    _Correctness_handler_1319._notlabels = None

    def _Correctness_handler_1365(self, run_num, implementation, learner):
        if (not self._state.learning_failed[implementation]):
            self._state.correctness_file[implementation].write(((((('-' * 40) + 'Run number') + str((run_num + 1))) + ('-' * 40)) + '\n'))
            self._state.correctness_file[implementation].write('\nTermination condition was violated. \n')
            self._state.learning_failed[implementation] = True
    _Correctness_handler_1365._labels = None
    _Correctness_handler_1365._notlabels = None

class Proposer(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ProposerReceivedEvent_0 = []
        self._ProposerReceivedEvent_1 = []
        self._ProposerReceivedEvent_2 = []
        self._ProposerReceivedEvent_3 = []
        self._ProposerReceivedEvent_4 = []
        self._ProposerReceivedEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_0', PatternExpr_1663, sources=[PatternExpr_1670], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_1', PatternExpr_1698, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_2', PatternExpr_1729, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_3', PatternExpr_1765, sources=[PatternExpr_1772], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_4', PatternExpr_1813, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_5', PatternExpr_1859, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, acceptors, benchmark, nacceptors, loss_rate, message_delay, round_time, tout_prop, run_num, implementation, **rest_2960):
        super().setup(acceptors=acceptors, benchmark=benchmark, nacceptors=nacceptors, loss_rate=loss_rate, message_delay=message_delay, round_time=round_time, tout_prop=tout_prop, run_num=run_num, implementation=implementation, **rest_2960)
        self._state.acceptors = acceptors
        self._state.benchmark = benchmark
        self._state.nacceptors = nacceptors
        self._state.loss_rate = loss_rate
        self._state.message_delay = message_delay
        self._state.round_time = round_time
        self._state.tout_prop = tout_prop
        self._state.run_num = run_num
        self._state.implementation = implementation
        self._state.n = None
        self._state.majority = self._state.acceptors
        self._state.correctness = ('Correctness' in str(self._state.benchmark))
        if self._state.correctness:
            self.send(('perf_refresh', self._state.implementation), to=self._state.benchmark)
        else:
            self.send(('perf_refresh_perf', self._state.implementation), to=self._state.benchmark)

    def run(self):
        while (not PatternExpr_1864.match_iter(self._ProposerReceivedEvent_5, SELF_ID=self._id)):
            self.to_consent()
            if self._state.round_time:
                time.sleep(self._state.round_time)
        self.output('MAIN Proposer terminating.')

    def to_consent(self):
        self._state.n = ((0, self._id) if (self._state.n == None) else ((self._state.n[0] + 1), self._id))
        self.send(('prepare', self._state.n), to=self._state.majority)
        super()._label('_st_label_1658', block=False)
        n2 = None

        def ExistentialOpExpr_1811():
            nonlocal n2
            for (_, _, (_ConstantPattern1828_, n2)) in self._ProposerReceivedEvent_4:
                if (_ConstantPattern1828_ == 'preempted'):
                    if (n2 > self._state.n):
                        return True
            return False
        _st_label_1658 = 0
        self._timer_start()
        while (_st_label_1658 == 0):
            _st_label_1658 += 1
            if (len({a for (_, (_, _, a), (_ConstantPattern1681_, _BoundPattern1683_, _)) in self._ProposerReceivedEvent_0 if (_ConstantPattern1681_ == 'respond') if (_BoundPattern1683_ == self._state.n)}) > (len(self._state.acceptors) / 2)):
                v = self.anyof(({v for (_, _, (_ConstantPattern1717_, _BoundPattern1719_, (n2, v))) in self._ProposerReceivedEvent_1 if (_ConstantPattern1717_ == 'respond') if (_BoundPattern1719_ == self._state.n) if (n2 == max({n2 for (_, _, (_ConstantPattern1746_, _BoundPattern1748_, (n2, _))) in self._ProposerReceivedEvent_2 if (_ConstantPattern1746_ == 'respond') if (_BoundPattern1748_ == self._state.n)}))} or {randint(1, 100)}))
                responded = {a for (_, (_, _, a), (_ConstantPattern1783_, _BoundPattern1785_, _)) in self._ProposerReceivedEvent_3 if (_ConstantPattern1783_ == 'respond') if (_BoundPattern1785_ == self._state.n)}
                self.send(('accept', self._state.n, v), to=responded)
                if self._state.correctness:
                    self.send(('perf_val_proposed', v, self._state.implementation), to=self._state.benchmark)
                self.debug('### chose', self._state.correctness)
                _st_label_1658 += 1
            elif ExistentialOpExpr_1811():
                self.output('Abandoned Proposal Number ', self._state.n)
                self._state.n = (n2[0], self._id)
                _st_label_1658 += 1
            elif self._timer_expired:
                self.output('failed proposal number', self._state.n)
                _st_label_1658 += 1
            else:
                super()._label('_st_label_1658', block=True, timeout=(self._state.tout_prop if self._state.tout_prop else TIMEOUT))
                _st_label_1658 -= 1

    def anyof(self, s):
        return (next(iter(s)) if s else None)

    def send(self, message, to):
        if ((not message[0].startswith('perf')) and (not (message[0] == 'done'))):
            if (not self._state.loss_rate):
                delay = random.uniform(0, self._state.message_delay)
                super()._label('_st_label_1928', block=False)
                _st_label_1928 = 0
                self._timer_start()
                while (_st_label_1928 == 0):
                    _st_label_1928 += 1
                    if False:
                        _st_label_1928 += 1
                    elif self._timer_expired:
                        _st_label_1928 += 1
                    else:
                        super()._label('_st_label_1928', block=True, timeout=delay)
                        _st_label_1928 -= 1
                super().send(message, to)
            elif (not self._state.message_delay):
                if (not self.lose_message(self._state.loss_rate)):
                    super().send(message, to)
                else:
                    self.output('Losing message', message)
        else:
            super().send(message, to)

    def lose_message(self, loss_rate):
        return (random.random() < loss_rate)

class Acceptor(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._AcceptorSentEvent_1 = []
        self._AcceptorSentEvent_2 = []
        self._AcceptorSentEvent_3 = []
        self._AcceptorSentEvent_5 = []
        self._AcceptorSentEvent_7 = []
        self._AcceptorReceivedEvent_8 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_0', PatternExpr_1996, sources=[PatternExpr_2003], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_1995]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_1', PatternExpr_2009, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_2', PatternExpr_2038, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_3', PatternExpr_2064, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_4', PatternExpr_2099, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_2098]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_5', PatternExpr_2112, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_6', PatternExpr_2145, sources=[PatternExpr_2149], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_2144]), da.pat.EventPattern(da.pat.SentEvent, '_AcceptorSentEvent_7', PatternExpr_2162, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_8', PatternExpr_2208, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, learners, loss_rate, message_delay, run_num, implementation, **rest_2960):
        super().setup(learners=learners, loss_rate=loss_rate, message_delay=message_delay, run_num=run_num, implementation=implementation, **rest_2960)
        self._state.learners = learners
        self._state.loss_rate = loss_rate
        self._state.message_delay = message_delay
        self._state.run_num = run_num
        self._state.implementation = implementation
        pass

    def run(self):
        super()._label('_st_label_2205', block=False)
        _st_label_2205 = 0
        while (_st_label_2205 == 0):
            _st_label_2205 += 1
            if PatternExpr_2213.match_iter(self._AcceptorReceivedEvent_8, SELF_ID=self._id):
                _st_label_2205 += 1
            else:
                super()._label('_st_label_2205', block=True)
                _st_label_2205 -= 1
        self.output('MAIN Acceptor terminating.')

    def anyof(self, s):
        "return any element of set s if s is not empty or 'None' otherwise"
        return (next(iter(s)) if s else None)

    def send(self, message, to):
        if ((not message[0].startswith('perf')) and (not (message[0] == 'done'))):
            if (not self._state.loss_rate):
                delay = random.uniform(0, self._state.message_delay)
                super()._label('_st_label_2270', block=False)
                _st_label_2270 = 0
                self._timer_start()
                while (_st_label_2270 == 0):
                    _st_label_2270 += 1
                    if False:
                        _st_label_2270 += 1
                    elif self._timer_expired:
                        _st_label_2270 += 1
                    else:
                        super()._label('_st_label_2270', block=True, timeout=delay)
                        _st_label_2270 -= 1
                super().send(message, to)
            elif (not self._state.message_delay):
                if (not self.lose_message(self._state.loss_rate)):
                    super().send(message, to)
                else:
                    self.output('Losing message', message)
        else:
            super().send(message, to)

    def lose_message(self, loss_rate):
        return (random.random() < loss_rate)

    def _Acceptor_handler_1995(self, n, p):
        n2 = None

        def UniversalOpExpr_2007():
            nonlocal n2
            for (_, _, (_ConstantPattern2025_, n2, _)) in self._AcceptorSentEvent_1:
                if (_ConstantPattern2025_ == 'respond'):
                    if (not (n > n2)):
                        return False
            return True
        if UniversalOpExpr_2007():
            maxprop = self.anyof({(n, v) for (_, _, (_ConstantPattern2054_, n, v)) in self._AcceptorSentEvent_2 if (_ConstantPattern2054_ == 'accepted') if (n == max({n for (_, _, (_ConstantPattern2079_, n, _)) in self._AcceptorSentEvent_3 if (_ConstantPattern2079_ == 'accepted')}))})
            self.send(('respond', n, maxprop), to=p)
    _Acceptor_handler_1995._labels = None
    _Acceptor_handler_1995._notlabels = None

    def _Acceptor_handler_2098(self, n, v):
        n2 = None

        def ExistentialOpExpr_2110():
            nonlocal n2
            for (_, _, (_ConstantPattern2128_, n2, _)) in self._AcceptorSentEvent_5:
                if (_ConstantPattern2128_ == 'respond'):
                    if (n2 > n):
                        return True
            return False
        if (not ExistentialOpExpr_2110()):
            self.send(('accepted', n, v), to=self._state.learners)
    _Acceptor_handler_2098._labels = None
    _Acceptor_handler_2098._notlabels = None

    def _Acceptor_handler_2144(self, m, p):
        if (m[0] == 'done'):
            return
        prop_queue = {b for (_, _, (_ConstantPattern2178_, b, _)) in self._AcceptorSentEvent_7 if (_ConstantPattern2178_ == 'respond')}
        if (len(prop_queue) > 0):
            max_b = max(prop_queue)
            if (m[1] < max_b):
                pass
    _Acceptor_handler_2144._labels = None
    _Acceptor_handler_2144._notlabels = None

class Learner(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._LearnerReceivedEvent_0 = []
        self._LearnerReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_0', PatternExpr_2353, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_1', PatternExpr_2379, sources=[PatternExpr_2386], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, acceptors, benchmark, loss_rate, message_delay, tout_learn, run_num, implementation, **rest_2960):
        super().setup(acceptors=acceptors, benchmark=benchmark, loss_rate=loss_rate, message_delay=message_delay, tout_learn=tout_learn, run_num=run_num, implementation=implementation, **rest_2960)
        self._state.acceptors = acceptors
        self._state.benchmark = benchmark
        self._state.loss_rate = loss_rate
        self._state.message_delay = message_delay
        self._state.tout_learn = tout_learn
        self._state.run_num = run_num
        self._state.implementation = implementation
        self._state.correctness = ('Correctness' in str(self._state.benchmark))

    def run(self):
        self.learn()
        self.output('MAIN Learner terminating.')
        self.send(('learned',), to=self.nodeof(self._id))

    def learn(self):
        super()._label('_st_label_2350', block=False)
        n = a = v = None

        def ExistentialOpExpr_2351():
            nonlocal n, a, v
            for (_, _, (_ConstantPattern2370_, n, v)) in self._LearnerReceivedEvent_0:
                if (_ConstantPattern2370_ == 'accepted'):
                    if (len({a for (_, (_, _, a), (_ConstantPattern2397_, _BoundPattern2399_, _BoundPattern2400_)) in self._LearnerReceivedEvent_1 if (_ConstantPattern2397_ == 'accepted') if (_BoundPattern2399_ == n) if (_BoundPattern2400_ == v)}) > (len(self._state.acceptors) / 2)):
                        return True
            return False
        _st_label_2350 = 0
        self._timer_start()
        while (_st_label_2350 == 0):
            _st_label_2350 += 1
            if ExistentialOpExpr_2351():
                self.output('learned', n, v)
                if self._state.correctness:
                    self.send(('perf_value_learned', v, self._state.run_num, self._state.implementation), to=self._state.benchmark)
                _st_label_2350 += 1
            elif self._timer_expired:
                self.output('failed learning anything')
                if self._state.correctness:
                    self.send(('perf_value_not_learned', self._state.run_num, self._state.implementation), to=self._state.benchmark)
                else:
                    self.send(('perf_value_not_learned_dur_perf', self._state.run_num, self._state.implementation), to=self._state.benchmark)
                _st_label_2350 += 1
            else:
                super()._label('_st_label_2350', block=True, timeout=((self._state.tout_learn * 10) if self._state.tout_learn else (TIMEOUT * 10)))
                _st_label_2350 -= 1

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._Node_ReceivedEvent_0 = []
        self._Node_ReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_2853, sources=[PatternExpr_2858], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_1', PatternExpr_2937, sources=[PatternExpr_2942], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        nproposers = (int(sys.argv[1]) if (len(sys.argv) > 1) else 5)
        nacceptors = (int(sys.argv[2]) if (len(sys.argv) > 2) else 3)
        nlearners = (int(sys.argv[3]) if (len(sys.argv) > 3) else 3)
        reps = (int(sys.argv[4]) if (len(sys.argv) > 4) else 1)
        loss_rate = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0)
        message_delay = (float(sys.argv[6]) if (len(sys.argv) > 6) else 0)
        round_time = (float(sys.argv[7]) if (len(sys.argv) > 7) else 0)
        tout_prop = (float(sys.argv[8]) if (len(sys.argv) > 8) else 0)
        tout_learn = (float(sys.argv[9]) if (len(sys.argv) > 9) else 0)
        perf_corr = (str(sys.argv[10]) if (len(sys.argv) > 10) else 'c')
        implementations = dict()
        implementations['main'] = dict()
        implementations['main']['Acceptor'] = Acceptor
        implementations['main']['Proposer'] = Proposer
        implementations['main']['Learner'] = Learner
        implementations['orig'] = dict()
        implementations['orig']['Acceptor'] = orig.Acceptor
        implementations['orig']['Proposer'] = orig.Proposer
        implementations['orig']['Learner'] = orig.Learner
        run_performance = False
        if (not (perf_corr == 'c')):
            benchmark = self.new(Performance, (self._id, nlearners, reps, loss_rate, message_delay, round_time, tout_prop, tout_learn, list(implementations.keys())), num=1)
            run_performance = True
        else:
            benchmark = self.new(Correctness, (self._id, nlearners, reps, loss_rate, message_delay, round_time, tout_prop, tout_learn, list(implementations.keys())), num=1)
        self._start(benchmark)
        for implementation in implementations:
            for i in range(reps):
                acceptors = self.new(implementations[implementation]['Acceptor'], num=nacceptors)
                proposers = self.new(implementations[implementation]['Proposer'], (acceptors, benchmark, nacceptors, loss_rate, message_delay, round_time, tout_prop, i, implementation), num=nproposers)
                learners = self.new(implementations[implementation]['Learner'], (acceptors, benchmark, loss_rate, message_delay, tout_learn, i, implementation), num=nlearners)
                for p in acceptors:
                    self._setup(p, (learners, loss_rate, message_delay, i, implementation))
                if run_performance:
                    self.send(('perf_time_start', i, time.time(), time.process_time(), implementation), to=benchmark)
                self._start(((acceptors | proposers) | learners))
                super()._label('_st_label_2844', block=False)
                l = None

                def UniversalOpExpr_2845():
                    nonlocal l
                    for l in learners:
                        if (not PatternExpr_2860.match_iter(self._Node_ReceivedEvent_0, _BoundPattern2866_=l)):
                            return False
                    return True
                _st_label_2844 = 0
                while (_st_label_2844 == 0):
                    _st_label_2844 += 1
                    if UniversalOpExpr_2845():
                        _st_label_2844 += 1
                    else:
                        super()._label('_st_label_2844', block=True)
                        _st_label_2844 -= 1
                else:
                    if (_st_label_2844 != 2):
                        continue
                if (_st_label_2844 != 2):
                    break
                self.send(('done',), to=(acceptors | proposers))
                if run_performance:
                    self.send(('perf_time_end', i, time.time(), time.process_time(), implementation), to=benchmark)
                print((((((('>' * 45) + 'Execution ends for ') + implementation.upper()) + ' Run ') + str((i + 1))) + ('<' * 50)))
        if run_performance:
            for implementation in implementations:
                self.send(('perf_print_times', implementation), to=benchmark)
        self.send(('done',), to=benchmark)
        super()._label('_st_label_2934', block=False)
        _st_label_2934 = 0
        self._timer_start()
        while (_st_label_2934 == 0):
            _st_label_2934 += 1
            if PatternExpr_2944.match_iter(self._Node_ReceivedEvent_1, _BoundPattern2950_=benchmark):
                _st_label_2934 += 1
            elif self._timer_expired:
                _st_label_2934 += 1
            else:
                super()._label('_st_label_2934', block=True, timeout=1)
                _st_label_2934 -= 1
        self.output(('--' * 15), 'MAIN PROCESS TERMINATING.')
